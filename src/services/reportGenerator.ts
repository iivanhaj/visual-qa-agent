import { BugReport, ReportConfig, Issue, Severity, IssueType } from '../types';
import { AISuggestionService } from './aiSuggestionService';

/**
 * Report Generator - Creates formatted design documents
 */
export class ReportGenerator {
    private aiService: AISuggestionService;

    constructor() {
        this.aiService = new AISuggestionService();
    }

    async generateMarkdown(report: BugReport, config: ReportConfig = { format: 'markdown', includeScreenshots: false, includeCodeSnippets: true }): Promise<string> {
        const lines: string[] = [];

        // Header
        lines.push('# Bug Detection Report');
        lines.push('');
        lines.push(`**URL:** ${report.url}`);
        lines.push(`**Scan Date:** ${report.timestamp.toLocaleString()}`);
        lines.push(`**Overall Health Score:** ${report.healthScore.overall}/100`);
        lines.push('');

        // AI-Powered Executive Summary
        lines.push('## ü§ñ AI-Powered Executive Summary');
        lines.push('');
        await this.aiService.initialize();
        const aiSummary = await this.aiService.generateExecutiveSummary(report);
        lines.push(aiSummary);
        lines.push('');
        lines.push('*Generated using OpenAI GPT-4o-mini*');
        lines.push('');

        // Score Breakdown
        lines.push('## Health Score Breakdown');
        lines.push('');
        lines.push('| Category | Score |');
        lines.push('|----------|-------|');
        lines.push(`| Functionality | ${report.healthScore.functionality}/100 |`);
        lines.push(`| Accessibility | ${report.healthScore.accessibility}/100 |`);
        lines.push(`| Performance | ${report.healthScore.performance}/100 |`);
        lines.push(`| SEO | ${report.healthScore.seo}/100 |`);
        lines.push(`| Security | ${report.healthScore.security}/100 |`);
        lines.push('');

        // Summary
        lines.push('## Summary');
        lines.push('');
        lines.push(`- **Total Issues:** ${report.summary.totalIssues}`);
        lines.push(`- **Critical:** ${report.summary.criticalCount}`);
        lines.push(`- **High:** ${report.summary.highCount}`);
        lines.push(`- **Medium:** ${report.summary.mediumCount}`);
        lines.push(`- **Low:** ${report.summary.lowCount}`);
        lines.push(`- **Info:** ${report.summary.infoCount}`);
        lines.push('');

        // Issues by Severity
        const criticalIssues = report.allIssues.filter(i => i.severity === Severity.Critical);
        const highIssues = report.allIssues.filter(i => i.severity === Severity.High);
        const mediumIssues = report.allIssues.filter(i => i.severity === Severity.Medium);
        const lowIssues = report.allIssues.filter(i => i.severity === Severity.Low);

        if (criticalIssues.length > 0) {
            lines.push('## üö® Critical Issues');
            lines.push('');
            lines.push('> **URGENT:** These issues require immediate attention.');
            lines.push('');
            criticalIssues.forEach((issue, index) => {
                lines.push(...this.formatIssue(issue, index + 1, config));
            });
        }

        if (highIssues.length > 0) {
            lines.push('## ‚ö†Ô∏è High Priority Issues');
            lines.push('');
            highIssues.forEach((issue, index) => {
                lines.push(...this.formatIssue(issue, index + 1, config));
            });
        }

        if (mediumIssues.length > 0) {
            lines.push('## üìã Medium Priority Issues');
            lines.push('');
            mediumIssues.forEach((issue, index) => {
                lines.push(...this.formatIssue(issue, index + 1, config));
            });
        }

        if (lowIssues.length > 0) {
            lines.push('## ‚ÑπÔ∏è Low Priority Issues');
            lines.push('');
            lowIssues.forEach((issue, index) => {
                lines.push(...this.formatIssue(issue, index + 1, config));
            });
        }

        // Test Results Summary
        lines.push('## Test Results');
        lines.push('');
        lines.push('| Test Type | Status | Passed | Failed | Duration |');
        lines.push('|-----------|--------|--------|--------|----------|');
        report.testResults.forEach(result => {
            const status = result.passed ? '‚úÖ Pass' : '‚ùå Fail';
            lines.push(`| ${result.testType} | ${status} | ${result.passedChecks} | ${result.failedChecks} | ${result.duration}ms |`);
        });
        lines.push('');

        // Recommendations
        lines.push('## Recommendations');
        lines.push('');
        lines.push(this.generateRecommendations(report));
        lines.push('');

        // Footer
        lines.push('---');
        lines.push('');
        lines.push('*Report generated by Visual QA Agent - Advanced Bug Detector*');
        lines.push('');

        return lines.join('\n');
    }

    generateJSON(report: BugReport): string {
        return JSON.stringify(report, null, 2);
    }

    private formatIssue(issue: Issue, index: number, config: ReportConfig): string[] {
        const lines: string[] = [];

        lines.push(`### ${index}. ${issue.title}`);
        lines.push('');
        lines.push(`**Type:** ${issue.type} | **Severity:** ${issue.severity.toUpperCase()}`);
        lines.push('');
        lines.push(`**Description:** ${issue.description}`);
        lines.push('');
        lines.push(`**Location:** \`${issue.location}\``);
        lines.push('');

        if (issue.element && config.includeCodeSnippets) {
            lines.push('<details>');
            lines.push('<summary>View Element</summary>');
            lines.push('');
            lines.push('```html');
            lines.push(issue.element);
            lines.push('```');
            lines.push('</details>');
            lines.push('');
        }

        lines.push('**How to Fix:**');
        lines.push('');
        lines.push(issue.suggestion);
        lines.push('');

        if (issue.codeSnippet && config.includeCodeSnippets) {
            lines.push('**Code Example:**');
            lines.push('');
            lines.push('Before:');
            lines.push('```html');
            lines.push(issue.codeSnippet.before);
            lines.push('```');
            lines.push('');
            lines.push('After:');
            lines.push('```html');
            lines.push(issue.codeSnippet.after);
            lines.push('```');
            lines.push('');
        }

        if (issue.resources && issue.resources.length > 0) {
            lines.push('**Resources:**');
            issue.resources.forEach(resource => {
                lines.push(`- ${resource}`);
            });
            lines.push('');
        }

        lines.push('---');
        lines.push('');

        return lines;
    }

    private generateRecommendations(report: BugReport): string {
        const recommendations: string[] = [];

        if (report.summary.criticalCount > 0) {
            recommendations.push('1. **Address critical issues immediately** - These can severely impact user experience or security.');
        }

        if (report.healthScore.security < 80) {
            recommendations.push('2. **Improve security** - Fix mixed content issues and ensure forms use HTTPS.');
        }

        if (report.healthScore.accessibility < 70) {
            recommendations.push('3. **Enhance accessibility** - Add proper labels, ARIA attributes, and ensure keyboard navigation works.');
        }

        if (report.healthScore.performance < 70) {
            recommendations.push('4. **Optimize performance** - Reduce DOM complexity, implement lazy loading, and minimize render-blocking resources.');
        }

        if (report.healthScore.seo < 70) {
            recommendations.push('5. **Improve SEO** - Add missing meta tags, fix heading hierarchy, and ensure all images have alt text.');
        }

        if (recommendations.length === 0) {
            return 'Great job! Your page has minimal issues. Continue monitoring and testing regularly.';
        }

        return recommendations.join('\n');
    }
}
